/**
 * ReleaseNotifier ‚Äî Posts version info and release notes to Slack on startup.
 * Reads dist/version.json (generated by CI) and posts to DEFAULT_UPDATE_CHANNEL.
 */

import { WebClient } from '@slack/web-api';
import { readFileSync, existsSync } from 'fs';
import path from 'path';
import { Logger } from './logger';

const logger = new Logger('ReleaseNotifier');

export interface VersionInfo {
  version: string;
  previousVersion: string;
  tag: string;
  previousTag: string;
  commitHash: string;
  commitHashShort: string;
  commitTime: string;
  branch: string;
  buildTime: string;
  releaseNotes: string;
}

function loadVersionInfo(): VersionInfo | null {
  const versionPath = path.join(process.cwd(), 'dist', 'version.json');
  if (!existsSync(versionPath)) {
    logger.debug('No dist/version.json found, skipping release notification');
    return null;
  }

  try {
    const content = readFileSync(versionPath, 'utf-8');
    return JSON.parse(content) as VersionInfo;
  } catch (error) {
    logger.warn('Failed to read version.json', { error: (error as Error).message });
    return null;
  }
}

function resolveChannel(client: WebClient, channelName: string): Promise<string | null> {
  // If it's already an ID (starts with C), return as-is
  if (channelName.startsWith('C')) return Promise.resolve(channelName);

  // Strip # prefix
  const name = channelName.replace(/^#/, '');

  return client.conversations.list({
    types: 'public_channel',
    limit: 1000,
  }).then(result => {
    const channel = result.channels?.find(ch => ch.name === name);
    return channel?.id || null;
  }).catch(error => {
    logger.warn('Failed to resolve channel name', { channelName, error: (error as Error).message });
    return null;
  });
}

function formatTimestamp(isoTime: string): string {
  try {
    const date = new Date(isoTime);
    return `<!date^${Math.floor(date.getTime() / 1000)}^{date_short_pretty} {time}|${isoTime}>`;
  } catch {
    return isoTime;
  }
}

/**
 * Send release notification to the configured channel.
 * Call after app.start() succeeds.
 */
export async function notifyRelease(client: WebClient): Promise<void> {
  const channelConfig = process.env.DEFAULT_UPDATE_CHANNEL;
  if (!channelConfig) {
    logger.debug('DEFAULT_UPDATE_CHANNEL not set, skipping release notification');
    return;
  }

  const versionInfo = loadVersionInfo();
  if (!versionInfo) return;

  const channelId = await resolveChannel(client, channelConfig);
  if (!channelId) {
    logger.warn('Could not resolve DEFAULT_UPDATE_CHANNEL', { channelConfig });
    return;
  }

  const isUpgrade = versionInfo.previousVersion !== '0.0.0' &&
    versionInfo.version !== versionInfo.previousVersion;

  const headerText = isUpgrade
    ? `üöÄ *v${versionInfo.version}* Î∞∞Ìè¨ ÏôÑÎ£å  _(v${versionInfo.previousVersion} ‚Üí v${versionInfo.version})_`
    : `üöÄ *v${versionInfo.version}* Î∞∞Ìè¨ ÏôÑÎ£å`;

  const blocks: any[] = [
    {
      type: 'header',
      text: {
        type: 'plain_text',
        text: `üöÄ soma-work v${versionInfo.version} Î∞∞Ìè¨`,
        emoji: true,
      },
    },
    {
      type: 'section',
      fields: [
        {
          type: 'mrkdwn',
          text: `*Î≤ÑÏ†Ñ*\n\`${versionInfo.tag}\``,
        },
        {
          type: 'mrkdwn',
          text: `*Î∏åÎûúÏπò*\n\`${versionInfo.branch}\``,
        },
        {
          type: 'mrkdwn',
          text: `*Ïª§Î∞ã*\n\`${versionInfo.commitHashShort}\``,
        },
        {
          type: 'mrkdwn',
          text: `*Ïª§Î∞ã ÏãúÍ∞Ñ*\n${formatTimestamp(versionInfo.commitTime)}`,
        },
      ],
    },
  ];

  // Release notes section
  if (versionInfo.releaseNotes) {
    blocks.push(
      { type: 'divider' },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*üìã Î≥ÄÍ≤Ω ÏÇ¨Ìï≠*${isUpgrade ? ` _(${versionInfo.previousTag} ‚Üí ${versionInfo.tag})_` : ''}\n\n${versionInfo.releaseNotes}`,
        },
      },
    );
  }

  // Footer
  blocks.push({
    type: 'context',
    elements: [
      {
        type: 'mrkdwn',
        text: `ÎπåÎìú: ${formatTimestamp(versionInfo.buildTime)} | Ïª§Î∞ã: \`${versionInfo.commitHash.substring(0, 12)}\``,
      },
    ],
  });

  try {
    await client.chat.postMessage({
      channel: channelId,
      text: headerText,
      blocks,
      unfurl_links: false,
      unfurl_media: false,
    });
    logger.info('Release notification sent', {
      channel: channelConfig,
      version: versionInfo.version,
    });
  } catch (error) {
    logger.warn('Failed to send release notification', {
      error: (error as Error).message,
      channel: channelConfig,
    });
  }
}

/**
 * Get the current version info (for status display or other uses).
 */
export function getVersionInfo(): VersionInfo | null {
  return loadVersionInfo();
}
